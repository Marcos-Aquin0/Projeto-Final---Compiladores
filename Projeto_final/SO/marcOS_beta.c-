void dispatcher_save(){
    aqui nao precisa salvar r31 e r2, vai direto, sem main
    int i;
    int aux;
    aux = 0;
    i = 63;

    se for salvar o so
        faço li $r1 15000
        -2 para o dispatcher
        -64 registradores com o while
        pc esta em r58
        - 4 de segurança do bcp, totalizando 70
        passo para o dispatcher load a partir do programa em r62
            move $r1 $r62
            -2 para o dispatcher
            -64 registradores com o while
            -1 carrega o pc instrução r40 e salta para ele + r44
            move r62 carregado para r1 

    se for salvar o programa
            
            se foi por quantum, salva quantum em r39
            -2 para o dispatcher
            - 64 registradores com o while
            -1 pc = r40 + r39 
                se quantum parou normalmente, vai somar 15
                separou em input e output, vai somar algum valor <= 15
            se foi por syscall, nao precisa salvar, basta seguir para o so e incrementar o halt lá

            passa para o dispatcher load para carregar o so
            -2 para o dispathcer
            -64 para os registradores com o while
            pula para r58 (instrucao) e carrega r1 e r2 do so


    while(aux < 64){
        position = position-aux; //r62
        salvar_reg(i,position);
        i = i - 1;
        aux = aux + 1;
    }
    position = position - 1;
    sw(position, lw(position) + quantum);
    if syscall 58, halt = 1;
}

void dispatcher_load(int position){
    int i;
    i = 63;
    while(i >= 0){
        position = position-(63-i);
        carregar_reg(i,position);
    }
    
}

criar sinal do quantum para interrupcao padrao
para interrupcao input e output
para interrupcao halt do syscall






//requisicao in e out, r0 e r3

verificacao do quantum
quantum == 15?
quantum recebe 0
assume mem_rom com as instrucoes, com o jump para o dispatcher

le os registradores do so e faz o syscall 58
processo acabou? tamanho == qtd
marca halt
se nao, ve o halt do proximo na fila
salva os registradores do so, pega o desvio e as info do proximo processo, faz um syscall de retorno para o pc do processo
se a instrucao é input ou output, executa primeiro, e automaticamente coloca quantum em 15
se todos sao halts, termina, volta para o menu
enquanto a variavel de todosHalts = 0, continua rodando a fila, if i == 3, i = 0


instrucao de quantum

dispatcher_load(1); //carrega referente ao r44 (instrucao)e r62 (memoria)

syscall envia um sinal paa o banco reg que seta o reg para 1
usar os registradores do processo
fazer o deslocamento dos pocesso para poder caber as funcoes da troca de contexto
